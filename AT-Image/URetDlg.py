"""Subclass of RetDlg, which is generated by wxFormBuilder."""

import wx

import CL

# Implementing RetDlg
class URetDlg( CL.RetDlg ):
	def __init__( self, parent ):
		CL.RetDlg.__init__( self, parent )

	# Handlers for RetDlg events.
	def OnSaveResult( self, event ):
		# TODO: Implement OnSaveResult
		dialog = wx.FileDialog(None, "ファイルを選択", wildcard="テキストファイル(UTF-8)(txt)|*.txt", style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT)
		if dialog.ShowModal() == wx.ID_OK:
			path = dialog.GetPath()
			self.m_textCtrl1.SaveFile(path)
		dialog.Destroy()

	def HistResult(self, cv_image, bx=None, by=None, ex=None, ey=None):
		"""ヒストグラム集計の結果を出力する
		"""
		self.m_textCtrl1.Clear()
#		self.m_textCtrl1.AppendText('データ名\t' + cv_image.name + '\n')
		if bx is not None:
			self.m_textCtrl1.AppendText('領域 ({} , {}) - ({} , {})\n'.format(bx, by, ex, ey))
		self.m_textCtrl1.AppendText('\t平均\t標準偏差\t中央値\n')
		if cv_image.kind == 'color':
			text = 'R\t{:>5.1f}\t{:>5.1f}\t{:>5.1f}\n'.format(*cv_image.dist_stat[2])  # @link https://www.headboost.jp/python-print-format-method/ (2022/04/15)
			self.m_textCtrl1.AppendText(text)
			text = 'G\t{:>5.1f}\t{:>5.1f}\t{:>5.1f}\n'.format(*cv_image.dist_stat[1])
			self.m_textCtrl1.AppendText(text)
			text = 'B\t{:>5.1f}\t{:>5.1f}\t{:>5.1f}\n'.format(*cv_image.dist_stat[0])
			self.m_textCtrl1.AppendText(text)
		else:
			text = 'K\t{:>5.1f}\t{:>5.1f}\t{:>5.1f}\n'.format(*cv_image.dist_stat[0])
			self.m_textCtrl1.AppendText(text)
		self.Show()

	def DistResult(self, cv_image, bx=None, by=None, ex=None, ey=None):
		"""水平・垂直方向周辺分布の集計結果を出力する
		"""
		self.m_textCtrl1.Clear()
#		self.m_textCtrl1.AppendText('データ名\t' + cv_image.name + '\n')
		if bx is not None:
			self.m_textCtrl1.AppendText('領域 ({} , {}) - ({} , {})\n'.format(bx, by, ex, ey))
		self.m_textCtrl1.AppendText('\t平均\t標準偏差\t中央値\t最大値\t最小値\n')
		if cv_image.kind == 'color':
			text = 'r\t{:>9.1f}\t{:>9.1f}\t{:>9.0f}\t{:>9.0f}\t{:>9.0f}\n'.format(*cv_image.dist_stat[2])
			self.m_textCtrl1.AppendText(text)
			text = 'g\t{:>9.1f}\t{:>9.1f}\t{:>9.0f}\t{:>9.0f}\t{:>9.0f}\n'.format(*cv_image.dist_stat[1])
			self.m_textCtrl1.AppendText(text)
			text = 'b\t{:>9.1f}\t{:>9.1f}\t{:>9.0f}\t{:>9.0f}\t{:>9.0f}\n'.format(*cv_image.dist_stat[0])
			self.m_textCtrl1.AppendText(text)
		else:
			text = 'k\t{:>9.1f}\t{:>9.1f}\t{:>9.0f}\t{:>9.0f}\t{:>9.0f}\n'.format(*cv_image.dist_stat[0])
			self.m_textCtrl1.AppendText(text)
		self.Show()

	def GetLineResult(self, cv_image, bx, by, ex, ey):
		"""線上のデータの集計結果を出力する
		"""
		self.m_textCtrl1.Clear()
#		self.m_textCtrl1.AppendText('データ名\t' + cv_image.name + '\n')
		self.m_textCtrl1.AppendText('直線 ({} , {}) - ({} , {})\n'.format(bx, by, ex, ey))
		self.m_textCtrl1.AppendText('\t平均\t標準偏差\t中央値\t最大値\t最小値\n')
		if cv_image.kind == 'color':
			text = 'r\t{:>9.1f}\t{:>9.1f}\t{:>9.0f}\t{:>9.0f}\t{:>9.0f}\n'.format(*cv_image.dist_stat[2])
			self.m_textCtrl1.AppendText(text)
			text = 'g\t{:>9.1f}\t{:>9.1f}\t{:>9.0f}\t{:>9.0f}\t{:>9.0f}\n'.format(*cv_image.dist_stat[1])
			self.m_textCtrl1.AppendText(text)
			text = 'b\t{:>9.1f}\t{:>9.1f}\t{:>9.0f}\t{:>9.0f}\t{:>9.0f}\n'.format(*cv_image.dist_stat[0])
			self.m_textCtrl1.AppendText(text)
		elif cv_image.kind == 'fft':
			text =  'real\t{:>9.1f}\t{:>9.1f}\t{:>9.0f}\t{:>9.0f}\t{:>9.0f}\n'.format(*cv_image.dist_stat[0])
			self.m_textCtrl1.AppendText(text)
			text = 'image\t{:>9.1f}\t{:>9.1f}\t{:>9.0f}\t{:>9.0f}\t{:>9.0f}\n'.format(*cv_image.dist_stat[1])
			self.m_textCtrl1.AppendText(text)
		else:
			text = 'k\t{:>9.1f}\t{:>9.1f}\t{:>9.0f}\t{:>9.0f}\t{:>9.0f}\n'.format(*cv_image.dist_stat[0])
			self.m_textCtrl1.AppendText(text)
		self.Show()

	def HoughCirclesResult(self, cv_image):
		"""ハフ変換で円を求めた結果を表示する
		"""
		self.m_textCtrl1.Clear()
#		self.m_textCtrl1.AppendText('データ名\t' + cv_image.name + '\n')
		self.m_textCtrl1.AppendText('パラメータ\t' + cv_image.log[-1] + '\n')
		self.m_textCtrl1.AppendText('検出した円\n')
		self.m_textCtrl1.AppendText('x座標\ty座標\t半径\n')
		if cv_image.circles is None:
			self.Show()
			return
		for dat in cv_image.circles[0]:
			x, y, r = dat
			self.m_textCtrl1.AppendText('{}\t{}\t{}\n'.format(x, y, r))
		self.Show()

	def LinesResult(self, cv_image):
		"""線分を求めた結果を表示する
		"""
		self.m_textCtrl1.Clear()
#		self.m_textCtrl1.AppendText('データ名\t' + cv_image.name + '\n')
		self.m_textCtrl1.AppendText('パラメータ\t' + cv_image.log[-1] + '\n')
		self.m_textCtrl1.AppendText('検出した線分\n')
		self.m_textCtrl1.AppendText('x1\ty1\tx2\ty2\n')
		if cv_image.lines is None:
			self.Show()
			return
		for line in cv_image.lines:
			x1, y1, x2, y2 = line[0]
			self.m_textCtrl1.AppendText('{}\t{}\t{}\t{}\n'.format(int(x1), int(y1), int(x2), int(y2)))
		self.Show()

	def LabelingResult(self, cv_image):
		"""ラベリング結果を表示する
		"""
		self.m_textCtrl1.Clear()
#		self.m_textCtrl1.AppendText('データ名\t' + cv_image.name + '\n')
		self.m_textCtrl1.AppendText('パラメータ\t' + cv_image.log[-1] + '\n')
		self.m_textCtrl1.AppendText('検出した物体 num,(x,y),size (番号は連続していない)\n')
		self.m_textCtrl1.AppendText('num\tx\ty\tsize\n')
		if cv_image.selected_stats is None:
			self.Show()
			return
		for i in range(len(cv_image.selected_stats)):
			label_num_a, x, y, w, h, size = cv_image.selected_stats[i]
			label_num_b, x0, y0           = cv_image.selected_centroids[i]
			self.m_textCtrl1.AppendText('{}\t{}\t{}\t{}\n'.format(label_num_a, x0, y0, size))
		self.m_textCtrl1.AppendText('\n')
		self.Show()

	def ViewItem(self, cv_image, x, y):
		"""(x, y)にある物体の情報を表示する
		"""
		label = cv_image.labels[y][x]  # すべての物体
		if label == 0:
			return
		for i in range(len(cv_image.selected_stats)):
			label_num_a, x, y, w, h, size = cv_image.selected_stats[i]
			label_num_b, x0, y0           = cv_image.selected_centroids[i]
			if label == label_num_a:
				self.m_textCtrl1.AppendText('{}\t{}\t{}\t{}\n'.format(label_num_a, x0, y0, size))
				break
		self.Show()
